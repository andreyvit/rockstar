#!/usr/bin/env bash
#
# Bureau - cli tool for managing AI agent report files.
#
# Portable bash (macOS bash 3.x + Linux bash), zero third-party deps.

set -euo pipefail

print_err() { printf '%s\n' "$*" >&2; }

die_usage() { print_err "$@"; exit 2; }

date_today() { date +%F; }

# Be forgiving: any entry name starting with 4 digits is considered a task.
is_task_dir_name() { [[ "$1" =~ ^[0-9]{4} ]]; }

list_task_dirs() {
  mkdir -p "$BUREAU_DIR" 2>/dev/null || return 1

  local -a dirs=()
  local dpath base

  for dpath in "$BUREAU_DIR"/*; do
    # Basename without calling external tools.
    base="${dpath##*/}"
    if is_task_dir_name "$base"; then
      dirs+=("$base")
    fi
  done

  local -a sorted=()
  local line
  # Read one task dir per line, preserving backslashes (-r) and not trimming spaces (IFS=).
  while IFS= read -r line; do
    sorted+=("$line")
  # Process substitution avoids a pipeline (which would run the loop in a subshell).
  done < <(printf '%s\n' "${dirs[@]}" | LC_ALL=C sort) # C locale => stable byte-wise sort

  printf '%s\n' "${sorted[@]}"
}

read_current_task_dir() {
  local link
  link="$BUREAU_DIR/current"

  if [[ ! -L "$link" ]]; then
    return 1
  fi

  local target
  target="$(readlink "$link" 2>/dev/null)" || return 1

  # Normalize to "just the directory name" even if the symlink points to a path.
  target="${target%/}"
  CURRENT_TASK_DIR="${target##*/}"
  return 0
}

update_current_symlink() {
  local task_dir="$1"

  mkdir -p "$BUREAU_DIR" || return 1
  local link
  link="$BUREAU_DIR/current"

  rm -f "$link" || return 1
  ln -s "$task_dir" "$link" || return 1
}

date_suffix_for_index() {
  local i="$1"
  local today
  today="$(date_today)"

  if [[ "$i" -eq 0 ]]; then
    printf '%s' "$today"
    return 0
  fi

  if [[ "$i" -le 24 ]]; then
    # Bash substring indexing is 0-based; i=1 => "b", i=24 => "y".
    local letters="abcdefghijklmnopqrstuvwxyz"
    local letter="${letters:i:1}"
    printf '%s%s' "$today" "$letter"
    return 0
  fi

  printf '%s%s%03d' "$today" "z" $((i + 1))
}

find_next_task_dir_name() {
  local slug="$1"
  local today
  today="$(date_today)"

  local i date_prefix candidate
  for ((i = 0; i < 1000; i++)); do
    date_prefix="$(date_suffix_for_index "$i")"
    [[ "$date_prefix" == "$today"* ]] || break

    # If any existing entry starts with "<date_prefix>", consider the prefix taken.
    local used=0
    local existing
    for existing in "$BUREAU_DIR/${date_prefix}"*; do
      # If the glob didn't match anything, the literal pattern still contains "*".
      if [[ "$existing" == *"*"* ]]; then
        break
      fi
      used=1
      break
    done

    if [[ "$used" -eq 0 ]]; then
      candidate="${date_prefix}-${slug}"
      printf '%s' "$candidate"
      return 0
    fi
  done

  return 1
}

list_report_files() {
  local task_dir="$1"
  local task_path
  task_path="$BUREAU_DIR/$task_dir"

  local -a files=()
  local fpath base
  for fpath in "$task_path"/*; do
    [[ -f "$fpath" ]] || continue
    base="${fpath##*/}"
    # Be forgiving: any filename starting with a digit is a report file.
    [[ "$base" =~ ^[0-9] ]] || continue
    files+=("$base")
  done

  local -a sorted=()
  local line
  # Read one filename per line; preserve backslashes and whitespace.
  while IFS= read -r line; do
    sorted+=("$line")
  done < <(printf '%s\n' "${files[@]}" | LC_ALL=C sort -n) # numeric sort by leading number

  if [[ "${#sorted[@]}" -le 50 ]]; then
    printf '%s\n' "${sorted[@]}"
    return 0
  fi

  local -a truncated=()
  local i
  for ((i = 0; i < 20; i++)); do
    truncated+=("${sorted[i]}")
  done
  for ((i = ${#sorted[@]} - 30; i < ${#sorted[@]}; i++)); do
    truncated+=("${sorted[i]}")
  done
  printf '%s\n' "${truncated[@]}"
}

find_next_report_number() {
  local task_dir="$1"

  local max=0
  local file n
  # Iterate report filenames line-by-line (not word-splitting).
  while IFS= read -r file; do
    [[ -n "$file" ]] || continue
    # Extract leading digits (the report number).
    [[ "$file" =~ ^([0-9]+) ]] || continue
    n="${BASH_REMATCH[1]}"
    if ((n > max)); then
      max="$n"
    fi
  done < <(list_report_files "$task_dir") # process substitution avoids a subshell loop

  printf '%s' $((max + 1))
}

new_report_file_name() {
  printf '%03d-%s.md' "$1" "$2"
}

print_hints() {
  printf '%s\n' "[to see current task files] bureau"
  printf '%s\n' "[to start new report file]  bureau -n <report-suffix>"
  printf '%s\n' "[to switch to a new task]   bureau -N <task-suffix>"
  printf '%s\n' "[to switch to a prior task] bureau -S <YYYY-MM-DD-task-suffix>"
  printf '%s\n' "[to see recent tasks]       bureau -T"
}

cmd_status() {
  if ! read_current_task_dir; then
    printf '%s\n' "No current task selected."
    printf '\n'
    print_hints
    return 0
  fi

  local reports_dir
  reports_dir="$BUREAU_DIR/$CURRENT_TASK_DIR"

  local -a report_files=()
  local line
  # Read report filenames produced by list_report_files() (one per line).
  while IFS= read -r line; do
    [[ -n "$line" ]] || continue
    report_files+=("$line")
  done < <(list_report_files "$CURRENT_TASK_DIR")

  printf 'Current task reports dir: %s\n' "$reports_dir"
  printf '\n'
  printf '[%d reports found]\n' "${#report_files[@]}"
  local f
  for f in "${report_files[@]}"; do
    printf '%s\n' "$f"
  done
  printf '\n'
  print_hints
}

cmd_new_report_file() {
  local suffix="$1"

  if [[ -z "${suffix//[[:space:]]/}" ]]; then
    die_usage "missing -n <report-suffix>"
  fi

  if ! read_current_task_dir; then
    print_err "No current task selected."
    exit 1
  fi

  local next_number
  next_number="$(find_next_report_number "$CURRENT_TASK_DIR")"

  printf '%s\n' "Write your report to:"
  printf '%s\n' "$BUREAU_DIR/$CURRENT_TASK_DIR/$(new_report_file_name "$next_number" "$suffix")"
}

cmd_list_recent_tasks() {
  local -a all=()
  local name
  # Read task dir names produced by list_task_dirs() (one per line).
  while IFS= read -r name; do
    [[ -n "$name" ]] || continue
    all+=("$name")
  done < <(list_task_dirs)

  local total="${#all[@]}"
  local start=0
  if ((total > 10)); then
    start=$((total - 10))
  fi

  local -a recent=()
  local i
  for ((i = start; i < total; i++)); do
    recent+=("${all[i]}")
  done

  printf '[%d recent tasks:]\n' "${#recent[@]}"
  local t
  for t in "${recent[@]}"; do
    printf '%s\n' "$t"
  done
}

cmd_new_task() {
  local slug="$1"

  if [[ -z "${slug//[[:space:]]/}" ]]; then
    die_usage "missing -N <task-suffix>"
  fi

  local task_dir
  if ! task_dir="$(find_next_task_dir_name "$slug")"; then
    print_err "Too many tasks for today (max 1000)."
    exit 1
  fi

  mkdir -p "$BUREAU_DIR/$task_dir" || exit 1
  update_current_symlink "$task_dir" || exit 1

  printf 'Switched to new task %s.\n' "$task_dir"
  printf '\n'
  cmd_status
}

cmd_switch_task() {
  local task_dir="$1"

  if [[ -z "${task_dir//[[:space:]]/}" ]]; then
    die_usage "missing -S <YYYY-MM-DD-task-suffix>"
  fi

  if [[ "$task_dir" == */* ]]; then
    print_err "Task dir name must not contain '/': $task_dir"
    exit 2
  fi

  if ! is_task_dir_name "$task_dir"; then
    print_err "Task dir name must start with 4 digits: $task_dir"
    exit 2
  fi

  if [[ ! -e "$BUREAU_DIR/$task_dir" ]]; then
    print_err "Task not found: $task_dir"
    exit 1
  fi

  update_current_symlink "$task_dir" || exit 1
  printf 'Switched to preexisting task %s.\n' "$task_dir"
  printf '\n'
  cmd_status
}

cmd_help() {
  printf '%s\n' "Bureau - cli tool for managing AI agent report files."
  printf '\n'
  cmd_status
  printf '\n'
  printf '%s\n' "Additional options:"
  printf '\n'
  printf '%s\n' "Override _tasks subdir name by setting BUREAU_DIR=<subdir>."
  printf '%s\n' "This can be a name, a relative path or an absolute path."
}

require_single_action() { [[ "$action" == "status" ]] || die_usage "only one of -n, -T, -N, -S can be used at a time"; }

require_arg() { [[ $# -ge 2 ]] || die_usage "missing argument for $1"; }

main() {
  local action="status"
  local action_arg=""
  local show_help=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--new-report)
        require_arg "-n/--new-report" "$@"
        require_single_action
        action="new-report"
        action_arg="$2"
        shift 2
        ;;
      -T|--list-tasks)
        require_single_action
        action="list-tasks"
        shift
        ;;
      -N|--new-task)
        require_arg "-N/--new-task" "$@"
        require_single_action
        action="new-task"
        action_arg="$2"
        shift 2
        ;;
      -S|--switch-task)
        require_arg "-S/--switch-task" "$@"
        require_single_action
        action="switch-task"
        action_arg="$2"
        shift 2
        ;;
      -h|--help)
        show_help=1
        shift
        ;;
      *)
        die_usage "unknown argument: $1"
        ;;
    esac
  done

  if [[ -z "${BUREAU_DIR:-}" ]]; then
    BUREAU_DIR="_tasks"
  fi
  # Normalize just a bit: drop a single trailing slash (except for "/").
  if [[ "$BUREAU_DIR" != "/" ]]; then
    BUREAU_DIR="${BUREAU_DIR%/}"
  fi

  if [[ "$show_help" -eq 1 ]]; then
    if [[ "$action" != "status" ]]; then
      die_usage "-h/--help cannot be combined with -n/-T/-N/-S"
    fi
    cmd_help
    return 0
  fi

  case "$action" in
    status) cmd_status ;;
    new-report) cmd_new_report_file "$action_arg" ;;
    list-tasks) cmd_list_recent_tasks ;;
    new-task) cmd_new_task "$action_arg" ;;
    switch-task) cmd_switch_task "$action_arg" ;;
    *) die_usage "internal error: unknown action $action" ;;
  esac
}

main "$@"
