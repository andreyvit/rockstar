#!/usr/bin/env bash
#
# Bureau - cli tool for managing AI agent report files.
#
# Portable bash (macOS bash 3.x + Linux bash), only uses portable POSIX tools
# that come preinstalled with the OS.
set -euo pipefail

print_err() { printf '%s\n' "$*" >&2; }

die_usage() { print_err "$@"; exit 2; }

date_today() { date +%F; }

TASK_NAME_RE='^[0-9]{4}'
REPORT_NAME_RE='^[0-9]'

list_basenames_matching() {
  local dir="$1"
  local type="$2" # "" or "-f" or "-d"
  local re="$3"

  local path base
  for path in "$dir"/*; do
    if [[ -n "$type" ]]; then
      test "$type" "$path" || continue
    fi

    base="${path##*/}"
    [[ "$base" =~ $re ]] || continue
    printf '%s\n' "$base"
  done
}

list_task_dirs() {
  if [[ ! -d "$BUREAU_DIR" ]]; then return 0; fi
  local -a sorted=($(list_basenames_matching "$BUREAU_DIR" "" "$TASK_NAME_RE" | sort))
  printf '%s\n' "${sorted[@]}"
}

read_current_task_dir() {
  local link
  link="$BUREAU_DIR/current"

  if [[ ! -L "$link" ]]; then
    return 1
  fi

  local target
  target="$(readlink "$link" 2>/dev/null)" || return 1

  # Normalize to "just the directory name" even if the symlink points to a path.
  target="${target%/}"
  CURRENT_TASK_DIR="${target##*/}"
  return 0
}

update_current_symlink() {
  local task_dir="$1"

  mkdir -p "$BUREAU_DIR" || return 1
  local link
  link="$BUREAU_DIR/current"

  rm -f "$link" || return 1
  ln -s "$task_dir" "$link" || return 1
}

date_suffix_for_index() {
  local i="$1"
  local today
  today="$(date_today)"

  if [[ "$i" -eq 0 ]]; then
    printf '%s' "$today"
    return 0
  fi

  if [[ "$i" -le 24 ]]; then
    # Bash substring indexing is 0-based; i=1 => "b", i=24 => "y".
    local letters="abcdefghijklmnopqrstuvwxyz"
    local letter="${letters:i:1}"
    printf '%s%s' "$today" "$letter"
    return 0
  fi

  printf '%s%s%03d' "$today" "z" $((i + 1))
}

find_next_task_dir_name() {
  local slug="$1"
  local today
  today="$(date_today)"

  local i date_prefix candidate
  for ((i = 0; i < 1000; i++)); do
    date_prefix="$(date_suffix_for_index "$i")"
    [[ "$date_prefix" == "$today"* ]] || break

    # If any existing entry starts with "<date_prefix>", consider the prefix taken.
    local used=0
    local existing
    for existing in "$BUREAU_DIR/${date_prefix}"*; do
      # If the glob didn't match anything, the literal pattern still contains "*".
      if [[ "$existing" == *"*"* ]]; then
        break
      fi
      used=1
      break
    done

    if [[ "$used" -eq 0 ]]; then
      candidate="${date_prefix}-${slug}"
      printf '%s' "$candidate"
      return 0
    fi
  done

  return 1
}

list_report_files() {
  local task_dir="$1"
  local task_path
  task_path="$BUREAU_DIR/$task_dir"

  local -a sorted=($(list_basenames_matching "$task_path" -f "$REPORT_NAME_RE" | sort -n))

  if [[ "${#sorted[@]}" -le 50 ]]; then
    printf '%s\n' "${sorted[@]}"
    return 0
  fi

  local -a truncated=()
  local i
  for ((i = 0; i < 20; i++)); do
    truncated+=("${sorted[i]}")
  done
  for ((i = ${#sorted[@]} - 30; i < ${#sorted[@]}; i++)); do
    truncated+=("${sorted[i]}")
  done
  printf '%s\n' "${truncated[@]}"
}

find_next_report_number() {
  local task_dir="$1"

  local max=0
  local file n
  for file in $(list_report_files "$task_dir"); do
    [[ "$file" =~ ^([0-9]+) ]] || continue
    n="${BASH_REMATCH[1]}"
    if ((n > max)); then max="$n"; fi
  done

  printf '%s' $((max + 1))
}

new_report_file_name() {
  printf '%03d-%s.md' "$1" "$2"
}

print_hints() {
  printf '%s\n' "[to see current task files] bureau"
  printf '%s\n' "[to start new report file]  bureau -n <report-suffix>"
  printf '%s\n' "[to switch to a new task]   bureau -N <task-suffix>"
  printf '%s\n' "[to switch to a prior task] bureau -S <YYYY-MM-DD-task-suffix>"
  printf '%s\n' "[to see recent tasks]       bureau -T"
}

cmd_status() {
  if ! read_current_task_dir; then
    printf '%s\n' "No current task selected."
    printf '\n'
    print_hints
    return 0
  fi

  local reports_dir
  reports_dir="$BUREAU_DIR/$CURRENT_TASK_DIR"

  local -a report_files=($(list_report_files "$CURRENT_TASK_DIR"))

  printf 'Current task reports dir: %s\n' "$reports_dir"
  printf '\n'
  printf '[%d reports found]\n' "${#report_files[@]}"
  local f
  for f in "${report_files[@]}"; do
    printf '%s\n' "$f"
  done
  printf '\n'
  print_hints
}

cmd_new_report_file() {
  local suffix="$1"

  if [[ -z "${suffix//[[:space:]]/}" ]]; then
    die_usage "missing -n <report-suffix>"
  fi

  if [[ "$suffix" == *" "* || "$suffix" == */* ]]; then
    die_usage "report suffix must not contain space or '/'"
  fi

  if [[ ! -d "$BUREAU_DIR" ]]; then
    print_err "No tasks dir: $BUREAU_DIR"
    exit 1
  fi

  if ! read_current_task_dir; then
    print_err "No current task selected."
    exit 1
  fi

  local next_number
  next_number="$(find_next_report_number "$CURRENT_TASK_DIR")"

  printf '%s\n' "Write your report to:"
  printf '%s\n' "$BUREAU_DIR/$CURRENT_TASK_DIR/$(new_report_file_name "$next_number" "$suffix")"
}

cmd_list_recent_tasks() {
  local -a all=($(list_task_dirs))

  local total="${#all[@]}"
  local start=0
  if ((total > 10)); then
    start=$((total - 10))
  fi

  local -a recent=()
  local i
  for ((i = start; i < total; i++)); do
    recent+=("${all[i]}")
  done

  printf '[%d recent tasks:]\n' "${#recent[@]}"
  local t
  for t in "${recent[@]}"; do
    printf '%s\n' "$t"
  done
}

cmd_new_task() {
  local slug="$1"

  if [[ -z "${slug//[[:space:]]/}" ]]; then
    die_usage "missing -N <task-suffix>"
  fi

  if [[ "$slug" == *" "* || "$slug" == */* ]]; then
    die_usage "task suffix must not contain space or '/'"
  fi

  mkdir -p "$BUREAU_DIR" || exit 1

  local task_dir
  if ! task_dir="$(find_next_task_dir_name "$slug")"; then
    print_err "Too many tasks for today (max 1000)."
    exit 1
  fi

  mkdir -p "$BUREAU_DIR/$task_dir" || exit 1
  update_current_symlink "$task_dir" || exit 1

  printf 'Switched to new task %s.\n' "$task_dir"
  printf '\n'
  cmd_status
}

cmd_switch_task() {
  local task_dir="$1"

  if [[ -z "${task_dir//[[:space:]]/}" ]]; then
    die_usage "missing -S <YYYY-MM-DD-task-suffix>"
  fi

  if [[ "$task_dir" == */* ]]; then
    print_err "Task dir name must not contain '/': $task_dir"
    exit 2
  fi

  if [[ ! "$task_dir" =~ $TASK_NAME_RE ]]; then
    print_err "Task dir name must start with 4 digits: $task_dir"
    exit 2
  fi

  if [[ ! -e "$BUREAU_DIR/$task_dir" ]]; then
    print_err "Task not found: $task_dir"
    exit 1
  fi

  update_current_symlink "$task_dir" || exit 1
  printf 'Switched to preexisting task %s.\n' "$task_dir"
  printf '\n'
  cmd_status
}

cmd_help() {
  printf '%s\n' "Bureau - cli tool for managing AI agent report files."
  printf '\n'
  cmd_status
  printf '\n'
  printf '%s\n' "Additional options:"
  printf '\n'
  printf '%s\n' "Override _tasks subdir name by setting BUREAU_DIR=<subdir>."
  printf '%s\n' "This can be a name, a relative path or an absolute path."
  printf '\n'
  printf '%s\n' "  --install-symlink       Install a global symlink (~/bin or /usr/local/bin)."
  printf '%s\n' "  --install               Install a global copy (~/bin or /usr/local/bin)."
}

require_single_action() { [[ -z "$action" ]] || die_usage "only one action allowed at a time"; }

require_arg() { [[ $# -ge 2 ]] || die_usage "missing argument for $1"; }

script_path() {
  local src="${BASH_SOURCE[0]}"
  case "$src" in
    /*) : ;;
    */*) src="$(pwd)/$src" ;;
    *)
      # If invoked via $PATH, ${BASH_SOURCE[0]} has no directory component.
      # Refuse, because install should be run from a known file path (e.g. ./bureau).
      die_usage "can't determine script path; run install as ./bureau --install or ./bureau --install-symlink"
      ;;
  esac
  printf '%s\n' "$src"
}

install_pick_dest_dir() {
  INSTALL_DEST_DIR=""
  INSTALL_SUDO=""

  if [[ -d "$HOME/bin" && -w "$HOME/bin" ]]; then
    INSTALL_DEST_DIR="$HOME/bin"
    printf 'Ensure %s is on your PATH.\n' "$HOME/bin"
    return 0
  fi

  if [[ ! -d /usr/local/bin ]]; then
    die_usage "/usr/local/bin not found; create it or use ~/bin"
  fi

  INSTALL_DEST_DIR="/usr/local/bin"
  if [[ -w "$INSTALL_DEST_DIR" ]]; then
    return 0
  fi

  command -v sudo >/dev/null 2>&1 || die_usage "sudo not found; can't install to /usr/local/bin"
  INSTALL_SUDO=sudo
}

cmd_install() {
  local src
  src="$(script_path)"

  install_pick_dest_dir

  local dest="$INSTALL_DEST_DIR/bureau"

  [[ -e "$dest" || -L "$dest" ]] && die_usage "can't install: already exists: $dest"

  $INSTALL_SUDO cp -f "$src" "$dest"
  $INSTALL_SUDO chmod 0755 "$dest"
  printf 'Installed %s\n' "$dest"
}

cmd_install_symlink() {
  local src
  src="$(script_path)"

  install_pick_dest_dir

  local dest="$INSTALL_DEST_DIR/bureau"
  [[ -e "$dest" || -L "$dest" ]] && die_usage "can't install: already exists: $dest"

  $INSTALL_SUDO ln -sf "$src" "$dest"
  printf 'Installed symlink %s -> %s\n' "$dest" "$src"
}

if [[ -z "${BUREAU_DIR:-}" ]]; then BUREAU_DIR="_tasks"; fi
if [[ "$BUREAU_DIR" != "/" ]]; then BUREAU_DIR="${BUREAU_DIR%/}"; fi

action=""
action_arg=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -n|--new-report)
      require_arg "$@"
      require_single_action
      action="cmd_new_report_file"
      action_arg="$2"
      shift 2 ;;
    -T|--list-tasks)
      require_single_action
      action="cmd_list_recent_tasks"
      shift ;;
    -N|--new-task)
      require_arg "$@"
      require_single_action
      action="cmd_new_task"
      action_arg="$2"
      shift 2 ;;
    -S|--switch-task)
      require_arg "$@"
      require_single_action
      action="cmd_switch_task"
      action_arg="$2"
      shift 2 ;;
    --install)
      require_single_action
      action="cmd_install"
      shift ;;
    --install-symlink)
      require_single_action
      action="cmd_install_symlink"
      shift ;;
    -h|--help) cmd_help; exit 0;;
    *)
      die_usage "unknown argument: $1" ;;
  esac
done

"${action:-cmd_status}" "$action_arg"
